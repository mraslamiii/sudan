# راهنمای پروتکل ارتباطی برای برنامه‌نویس میکروکنترلر

این سند برای توسعه‌دهندهٔ **میکروکنترلر** است که قرار است با اپ **خانه هوشمند سودان** از طریق **USB Serial** ارتباط برقرار کند. اپ روی تبلت/گوشی با کابل USB (و در صورت نیاز مبدل USB‑Serial) به میکرو وصل می‌شود؛ میکرو باید این پروتکل را دقیقاً رعایت کند تا اپ بتواند داده را بخواند و دستورات را بفرستد.

---

## فهرست

1. [اتصال و تنظیمات سریال](#۱-اتصال-و-تنظیمات-سریال)
2. [فرمت فریم (لایه انتقال)](#۲-فرمت-فریم-لایه-انتقال)
3. [انواع پیام و نقش میکرو](#۳-انواع-پیام-و-نقش-میکرو)
4. [درخواست‌های اپ و پاسخ مورد انتظار از میکرو](#۴-درخواست‌های-اپ-و-پاسخ-مورد-انتظار-از-میکرو)
5. [دستورات اپ و عملیات مورد انتظار در میکرو](#۵-دستورات-اپ-و-عملیات-مورد-انتظار-در-میکرو)
6. [فرمت متن (جداکننده‌ها)](#۶-فرمت-متن-جداکننده‌ها)
7. [جریان نمونه (لیست طبقات)](#۷-جریان-نمونه-لیست-طبقات)
8. [چک‌لیست پیاده‌سازی](#۸-چک‌لیست-پیاده‌سازی)

---

## ۱. اتصال و تنظیمات سریال

| پارامتر      | مقدار   | توضیح |
|-------------|---------|--------|
| **Baud Rate** | 9600   | ثابت در اپ |
| **Data Bits** | 8      | |
| **Stop Bits** | 1      | |
| **Parity**    | None   | |

- اپ به‌صورت **مشتری (client)** به پورت سریال وصل می‌شود (مثلاً از طریق USB OTG و مبدل USB‑Serial).
- میکرو باید در همان baud و 8N1 گوش دهد و فریم‌ها را طبق بخش بعد پارس کند.

---

## ۲. فرمت فریم (لایه انتقال)

**همهٔ پیام‌ها** (چه از اپ به میکرو، چه از میکرو به اپ) داخل یک **فریم** با ساختار زیر ارسال می‌شوند:

```
[STX][Type][Length][Data...][Checksum][ETX]
```

| فیلد       | طول (بایت) | مقدار / محاسبه |
|------------|------------|-----------------|
| **STX**    | 1          | `0x02` (Start of Text) |
| **Type**   | 1          | نوع پیام (جدول زیر) |
| **Length** | 1          | طول داده (تعداد بایت‌های Data) |
| **Data**   | Length     | دادهٔ خام (مثلاً رشتهٔ UTF-8) |
| **Checksum** | 1        | `(Type + Length + sum(Data bytes)) & 0xFF` |
| **ETX**    | 1          | `0x03` (End of Text) |

### انواع پیام (Type)

| مقدار (hex) | نام        | جهت       | توضیح |
|-------------|------------|-----------|--------|
| 0x01        | Command    | اپ → میکرو | دستور اجرایی (چراغ، پرده، طبقه، اتاق، …) |
| 0x02        | Request    | اپ → میکرو | درخواست داده (لیست طبقات، لیست اتاق‌ها، IP، …) |
| 0x03        | Response   | میکرو → اپ | پاسخ به Request (متن لیست‌ها یا دادهٔ دیگر) |
| 0x04        | Heartbeat  | اپ → میکرو | پینگ؛ میکرو می‌تواند نادیده بگیرد یا با ACK جواب دهد |
| 0x05        | PushState  | میکرو → اپ | (اختیاری) ارسال وضعیت از سمت میکرو |
| 0x06        | ACK        | میکرو → اپ | تأیید دریافت فریم معتبر |
| 0x15        | NAK        | میکرو → اپ | عدم تأیید (خطا یا داده نامعتبر) |

### فریم ACK/NAK (فقط از میکرو به اپ)

این فریم‌ها **فقط ۳ بایت** دارند (بدون Length و Data و Checksum):

- **ACK:** `0x02 0x06 0x03`  (STX, ACK, ETX)
- **NAK:** `0x02 0x15 0x03`  (STX, NAK, ETX)

اپ بعد از فرستادن یک فریم Command یا Request، در صورت دریافت ACK آن را «دریافت شده» در نظر می‌گیرد. اگر میکرو به یک Request پاسخ محتوایی (Response) می‌دهد، ارسال ACK قبل یا بعد از Response بسته به طراحی شما است؛ اپ عمدتاً منتظر یک فریم با Type = Response می‌ماند.

### محاسبه Checksum (مثال برای میکرو)

```c
// داده = رشتهٔ UTF-8 (مثلاً "@M_F_A")
uint8_t checksum = (uint8_t)(messageType + dataLength);
for (int i = 0; i < dataLength; i++)
  checksum += (uint8_t)data[i];
checksum &= 0xFF;
```

---

## ۳. انواع پیام و نقش میکرو

- **اپ فریم می‌فرستد (Command یا Request):** میکرو باید فریم را از روی STX تا ETX بخواند، Length و Checksum را چک کند، در صورت صحیح بودن **ACK** بفرستد و بر اساس Type و محتوای Data عمل کند.
- **Request (Type=0x02):** اپ منتظر یک فریم **Response (Type=0x03)** با محتوای متن (لیست طبقات، لیست اتاق‌ها و غیره) است. میکرو بعد از ACK (یا بدون آن، بسته به طراحی) همان پاسخ را در یک فریم با Type=0x03 و Data=متن پاسخ بفرستد.
- **Command (Type=0x01):** میکرو دستور را اجرا می‌کند (چراغ، پرده، ایجاد/ویرایش/حذف طبقه یا اتاق، سناریو و …). نیاز به پاسخ محتوایی نیست؛ ارسال ACK کافی است.
- **Heartbeat (Type=0x04):** اپ هر حدود ۱ ثانیه پینگ می‌فرستد. میکرو می‌تواند فقط ACK بفرستد یا نادیده بگیرد.

---

## ۴. درخواست‌های اپ و پاسخ مورد انتظار از میکرو

همهٔ **Data** در اینجا به‌صورت **رشتهٔ متنی (UTF-8)** است. جداکننده‌ها در [بخش ۶](#۶-فرمت-متن-جداکننده‌ها) تعریف شده‌اند.

| درخواست (Data در فریم Request) | پاسخ مورد انتظار (Data در فریم Response) |
|--------------------------------|------------------------------------------|
| `@M_IP` | متن مربوط به پیکربندی IP (فرمت بر عهدهٔ طراحی شما) |
| `@M_F_C` | تعداد طبقات (مثلاً یک خط حاوی یک عدد) |
| `@M_F_` + شماره (مثلاً `@M_F_1`) | دادهٔ یک طبقه (در صورت پشتیبانی) |
| **`@M_F_A`** | **لیست طبقات:** هر خط یک طبقه. هر خط: `id\|name\|order\|roomIds` — roomIds با کاما بدون فاصله. مثال: `floor_1\|طبقه اول\|0\|room_a,room_b` |
| **`@M_R`** | **لیست اتاق‌ها:** هر خط یک اتاق. هر خط: `id\|name\|order\|floorId\|icon\|deviceIds\|isGeneral` — deviceIds با کاما؛ isGeneral مقدار `1` یا `0`. مثال: `room_1\|اتاق نشیمن\|0\|floor_1\|living\|\|0` |

اگر میکرو لیست ندارد یا خطا رخ داده، می‌تواند Response با دادهٔ خالی یا یک خط خطا بفرستد؛ اپ در صورت خالی بودن یا نامعتبر بودن، از کش محلی استفاده می‌کند.

---

## ۵. دستورات اپ و عملیات مورد انتظار در میکرو

Data همهٔ این دستورات داخل فریم **Command (Type=0x01)** ارسال می‌شود. محتوای Data به‌صورت رشته است؛ در صورت چندبخشی بودن با `\n` (جداکنندهٔ خط) جدا می‌شود.

### ۵.۱ طبقات (Floors)

| Data ارسالی از اپ | عملیات میکرو |
|-------------------|---------------|
| `&M_F_N` + `\n` + یک خط | **ایجاد طبقه.** خط = `id\|name\|order\|roomIds` (roomIds با کاما). میکرو این طبقه را ذخیره/اعمال کند. |
| `&M_F_U` + `\n` + یک خط | **به‌روزرسانی طبقه.** همان فرمت خط؛ میکرو رکورد با همان id را به‌روز کند. |
| `&M_F_D` + `\n` + `floorId` | **حذف طبقه.** میکرو طبقهٔ با id داده‌شده را حذف کند. |

### ۵.۲ اتاق‌ها (Rooms)

| Data ارسالی از اپ | عملیات میکرو |
|-------------------|---------------|
| `&M_R_N` + `\n` + یک خط | **ایجاد اتاق.** خط = `id\|name\|order\|floorId\|icon\|deviceIds\|isGeneral` (deviceIds با کاما؛ isGeneral برابر 1 یا 0). |
| `&M_R_U` + `\n` + یک خط | **به‌روزرسانی اتاق.** همان فرمت؛ میکرو رکورد با همان id را به‌روز کند. |
| `&M_R_D` + `\n` + `roomId` | **حذف اتاق.** میکرو اتاق با id داده‌شده را حذف کند. |

### ۵.۳ دستگاه‌ها (Devices)

همهٔ دستورات زیر به‌صورت **یک رشتهٔ متنی** در Data فریم Command ارسال می‌شوند. `deviceId` معمولاً یک شناسهٔ متنی است (مثلاً `1` یا `light_1`).

**چراغ (Headline `U`):**

| Data | معنای دستور |
|------|--------------|
| `&U` + deviceId + `1` | روشن |
| `&U` + deviceId + `0` | خاموش |
| `&U` + deviceId + `RRGGBB` | تنظیم رنگ (هگز بدون #، مثلاً FF0000 برای قرمز) |
| `&U` + deviceId + `000`..`100` | تنظیم روشنایی (۳ رقم) |

**پرده (Headline `V`):**

| Data | معنای دستور |
|------|--------------|
| `&V` + deviceId + `O` | باز |
| `&V` + deviceId + `C` | بسته |
| `&V` + deviceId + `S` | توقف |
| `&V` + deviceId + `000`..`100` یا `O`/`C` | موقعیت (عدد سه‌رقمی یا O/C) |

**دما / ترموستات (Headline `W`):**

| Data | معنای دستور |
|------|--------------|
| `&W` + deviceId + `10`..`35` | دمای هدف (۲ رقم) |
| `&W` + deviceId + `A` | حالت Auto |
| `&W` + deviceId + `C` | حالت Cool |
| `&W` + deviceId + `H` | حالت Heat |

**موزیک / سناریو (Headline `X`):**

| Data | معنای دستور |
|------|--------------|
| `&X` + deviceId + `P` | پخش |
| `&X` + deviceId + `S` | توقف |
| `&X` + deviceId + `PREV` | قبلی |
| `&X` + deviceId + `NEXT` | بعدی |
| `&X` + deviceId + `VOL` + `000`..`100` | صدا (۳ رقم) |

**دزدگیر (Headline `X1`):**

| Data | معنای دستور |
|------|--------------|
| `&X1` + deviceId + `1` | فعال (Armed) |
| `&X1` + deviceId + `0` | غیرفعال (Disarmed) |

**آسانسور (Headline `E`):**

| Data | معنای دستور |
|------|--------------|
| `&E` + deviceId + `C` + شماره طبقه | فراخوانی به طبقهٔ داده‌شده |

**قفل در (Headline `L`):**

| Data | معنای دستور |
|------|--------------|
| `&L` + deviceId + `L` | قفل |
| `&L` + deviceId + `U` | باز (Unlock) |

**دوربین / آیفون (Headline `X2`):**

| Data | معنای دستور |
|------|--------------|
| `&X2` + deviceId + `1` | فعال |
| `&X2` + deviceId + `0` | غیرفعال |

**پریز / شارژر (Headline `Y`):**

| Data | معنای دستور |
|------|--------------|
| `&Y` + deviceId + `1` | روشن |
| `&Y` + deviceId + `0` | خاموش |
| `&Y` + deviceId + `C` | شارژ (مثلاً تبلت) |
| `&Y` + deviceId + `D` | دی‌شارژ |

**سناریو (اجرای سناریو از اپ):**

| Data | معنای دستور |
|------|--------------|
| `!&` + scenarioId | سناریو عمومی |
| `!^` + scenarioId | سناریو طبقه |
| `!~` + scenarioId | سناریو مکان |

میکرو با توجه به scenarioId و نوع سناریو، سناریوی از پیش تعریف‌شده را اجرا می‌کند (مثلاً مجموعه‌ای از دستورات چراغ/پرده/…).

---

## ۶. فرمت متن (جداکننده‌ها)

در پاسخ‌های متنی و در خطوط دستورات طبقه/اتاق از جداکننده‌های زیر استفاده می‌شود:

| جداکننده | کاراکتر | کاربرد |
|----------|----------|--------|
| فیلد    | `\|` (پایپ) | جدا کردن فیلدها در یک خط |
| خط (رکورد) | `\n` (newline) | جدا کردن هر طبقه/اتاق از دیگری |
| لیست (مثلاً شناسه‌ها) | `,` (کاما) | جدا کردن roomIds یا deviceIds در یک فیلد |

**مثال یک خط طبقه:**  
`floor_1|طبقه اول|0|room_living,room_kitchen`

**مثال یک خط اتاق:**  
`room_living|اتاق نشیمن|0|floor_1|living||0`  
(فیلد deviceIds خالی است؛ isGeneral=0)

---

## ۷. جریان نمونه (لیست طبقات)

1. اپ فریم **Request** با `Data = "@M_F_A"` می‌فرستد.
2. میکرو فریم را دریافت و چک می‌کند؛ در صورت معتبر بودن **ACK** می‌فرستد.
3. میکرو یک فریم **Response** با `Type=0x03` و `Data = متن چندخطی لیست طبقات` می‌فرستد (هر خط یک طبقه، مطابق جدول بخش ۴).
4. اپ پاسخ را پارس می‌کند و لیست طبقات را نمایش می‌دهد.

جریان برای `@M_R` (لیست اتاق‌ها) مشابه است؛ فقط محتوای Data مطابق فرمت اتاق است.

---

## ۸. چک‌لیست پیاده‌سازی

- [ ] پورت سریال با 9600, 8N1 باز و گوش دادن به بایت‌های ورودی.
- [ ] تشخیص فریم: پیدا کردن STX، خواندن Type و Length، خواندن Length بایت Data و یک بایت Checksum و ETX؛ بررسی صحت Checksum.
- [ ] در صورت معتبر بودن فریم ورودی: ارسال ACK (0x02 0x06 0x03).
- [ ] در صورت Request `@M_F_A`: ساخت متن لیست طبقات و ارسال در فریم Response.
- [ ] در صورت Request `@M_R`: ساخت متن لیست اتاق‌ها و ارسال در فریم Response.
- [ ] در صورت Command با پیشوند `&M_F_N` / `&M_F_U` / `&M_F_D`: ایجاد/به‌روزرسانی/حذف طبقه.
- [ ] در صورت Command با پیشوند `&M_R_N` / `&M_R_U` / `&M_R_D`: ایجاد/به‌روزرسانی/حذف اتاق.
- [ ] در صورت Command با پیشوند `&U`, `&V`, `&W`, `&X`, `&X1`, `&E`, `&L`, `&X2`, `&Y`: اجرای دستور دستگاه مربوط.
- [ ] در صورت Command با پیشوند `!&`, `!^`, `!~`: اجرای سناریو با شناسهٔ داده‌شده.
- [ ] استفاده از جداکننده‌های `|` و `\n` و `,` در همهٔ متن‌های ارسالی به اپ.

با رعایت این پروتکل، اپ و میکرو می‌توانند به‌درستی با هم ارتباط برقرار کنند. برای تست بدون میکرو واقعی می‌توان از اسکریپت پایتون در پوشهٔ `scripts/usb_serial_simulator.py` استفاده کرد که همین پروتکل را شبیه‌سازی می‌کند.
